先不提指针,先考察一下普通函数

```c++
void fun(int n)
{
    n++;
}
int main()
{
    int p=0;
  	fun(p);
  	printf("%d\n",p);
}
```

在上面一个函数中,我们向函数`fun`传递了p,在fun中我们对形参进行了自增,而很明显,对形参的自增并不会影响真正的实参p,p还是0.

---

那么如何我们可以通过改变形参,可以达到改变实参的效果呢,C中有指针这个概念

```c++
void pfun(int * n)
{
    (*n)++;
}
int main()
{
    int p=0;
  	pfun(&p);
  	printf("%d\n",p);
}
```

在上面这段代码中,我们通过&将p的地址传入函数pfun,从而实现了对形参的"改变",但这只是开始

----

```c++
void pfun(int *n)
{
  	(*n)++;
    static int in[3] = {999, 1111, 2222};
    n = in;
}
int main()
{
    int arr[3] = {666, 777, 888};
    int *p = arr;
    pfun(p);
  	printf("%d\n",arr[0]);
    printf("%d\n", p[0]);
    return 0;
}
```

之前的代码是从int传int*之间的,很容易理解

那我们来考察上面这一段代码,main函数中,p指向了数组arr,然后将p传入了pfun中,对形参的指向进行了更改,那么p这个实参到底会不会被修改指向呢,也就是p最后是指向那个pfun中static数组in,还是main中的数组arr?

答案是,p仍然指向着arr,两个的输出都是667.因为这是`int*` 传 `int*`,参照`int`传`int`那个情况,对形参的改变并不会影响实参,即`int*`对`int*`的时,你可以修改形参的值,实参的值也是会变,但是你修改形参的指向,实参的指向不会变.

----

```c++
void pfun(int **n)
{
    static int in[3] = {999, 1111, 2222};
    *n = in;
}
int main()
{
    int arr[3] = {666, 777, 888};
    int *p = arr;
    pfun(&p);
    printf("%d\n", p[0]);
    return 0;
}
// 当然这样的代码还是少写微妙,仅仅举例说明
```

而上面这段代码,是`int*`传 `int**`的,`p[0]` 的输出是666,成功修改了p的指向

#### 总结

那么其实也就是说,如果你实参是int类型,你要修改形参达到实参也被修改,那你的形参类型得是int*

如果你的实参是`int*`类型,而形参类型是`int*`,你可以对其赋值比如 `p[0]=666`,但是你不能对其**修改指向** (`p=in` ,算是指针层面的修改)